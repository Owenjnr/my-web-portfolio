{"ast":null,"code":"var parser = require('js-yaml');\n\nvar optionalByteOrderMark = '\\\\ufeff?';\nvar platform = typeof process !== 'undefined' ? process.platform : '';\nvar pattern = '^(' + optionalByteOrderMark + '(= yaml =|---)' + '$([\\\\s\\\\S]*?)' + '^(?:\\\\2|\\\\.\\\\.\\\\.)\\\\s*' + '$' + (platform === 'win32' ? '\\\\r?' : '') + '(?:\\\\n)?)'; // NOTE: If this pattern uses the 'g' flag the `regex` variable definition will\n// need to be moved down into the functions that use it.\n\nvar regex = new RegExp(pattern, 'm');\nmodule.exports = extractor;\nmodule.exports.test = test;\n\nfunction extractor(string, options) {\n  string = string || '';\n  var defaultOptions = {\n    allowUnsafe: false\n  };\n  options = options instanceof Object ? { ...defaultOptions,\n    ...options\n  } : defaultOptions;\n  options.allowUnsafe = Boolean(options.allowUnsafe);\n  var lines = string.split(/(\\r?\\n)/);\n\n  if (lines[0] && /= yaml =|---/.test(lines[0])) {\n    return parse(string, options.allowUnsafe);\n  } else {\n    return {\n      attributes: {},\n      body: string,\n      bodyBegin: 1\n    };\n  }\n}\n\nfunction computeLocation(match, body) {\n  var line = 1;\n  var pos = body.indexOf('\\n');\n  var offset = match.index + match[0].length;\n\n  while (pos !== -1) {\n    if (pos >= offset) {\n      return line;\n    }\n\n    line++;\n    pos = body.indexOf('\\n', pos + 1);\n  }\n\n  return line;\n}\n\nfunction parse(string, allowUnsafe) {\n  var match = regex.exec(string);\n\n  if (!match) {\n    return {\n      attributes: {},\n      body: string,\n      bodyBegin: 1\n    };\n  }\n\n  var loader = allowUnsafe ? parser.load : parser.safeLoad;\n  var yaml = match[match.length - 1].replace(/^\\s+|\\s+$/g, '');\n  var attributes = loader(yaml) || {};\n  var body = string.replace(match[0], '');\n  var line = computeLocation(match, string);\n  return {\n    attributes: attributes,\n    body: body,\n    bodyBegin: line,\n    frontmatter: yaml\n  };\n}\n\nfunction test(string) {\n  string = string || '';\n  return regex.test(string);\n}","map":{"version":3,"sources":["/Users/papi/Papi/Web/Projects/EO/node_modules/front-matter/index.js"],"names":["parser","require","optionalByteOrderMark","platform","process","pattern","regex","RegExp","module","exports","extractor","test","string","options","defaultOptions","allowUnsafe","Object","Boolean","lines","split","parse","attributes","body","bodyBegin","computeLocation","match","line","pos","indexOf","offset","index","length","exec","loader","load","safeLoad","yaml","replace","frontmatter"],"mappings":"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","sourcesContent":["var parser = require('js-yaml')\nvar optionalByteOrderMark = '\\\\ufeff?'\nvar platform = typeof process !== 'undefined' ? process.platform : ''\nvar pattern = '^(' +\n  optionalByteOrderMark +\n  '(= yaml =|---)' +\n  '$([\\\\s\\\\S]*?)' +\n  '^(?:\\\\2|\\\\.\\\\.\\\\.)\\\\s*' +\n  '$' +\n  (platform === 'win32' ? '\\\\r?' : '') +\n  '(?:\\\\n)?)'\n// NOTE: If this pattern uses the 'g' flag the `regex` variable definition will\n// need to be moved down into the functions that use it.\nvar regex = new RegExp(pattern, 'm')\n\nmodule.exports = extractor\nmodule.exports.test = test\n\nfunction extractor (string, options) {\n  string = string || ''\n  var defaultOptions = { allowUnsafe: false }\n  options = options instanceof Object ? { ...defaultOptions, ...options } : defaultOptions\n  options.allowUnsafe = Boolean(options.allowUnsafe)\n  var lines = string.split(/(\\r?\\n)/)\n  if (lines[0] && /= yaml =|---/.test(lines[0])) {\n    return parse(string, options.allowUnsafe)\n  } else {\n    return {\n      attributes: {},\n      body: string,\n      bodyBegin: 1\n    }\n  }\n}\n\nfunction computeLocation (match, body) {\n  var line = 1\n  var pos = body.indexOf('\\n')\n  var offset = match.index + match[0].length\n\n  while (pos !== -1) {\n    if (pos >= offset) {\n      return line\n    }\n    line++\n    pos = body.indexOf('\\n', pos + 1)\n  }\n\n  return line\n}\n\nfunction parse (string, allowUnsafe) {\n  var match = regex.exec(string)\n  if (!match) {\n    return {\n      attributes: {},\n      body: string,\n      bodyBegin: 1\n    }\n  }\n\n  var loader = allowUnsafe ? parser.load : parser.safeLoad\n  var yaml = match[match.length - 1].replace(/^\\s+|\\s+$/g, '')\n  var attributes = loader(yaml) || {}\n  var body = string.replace(match[0], '')\n  var line = computeLocation(match, string)\n\n  return {\n    attributes: attributes,\n    body: body,\n    bodyBegin: line,\n    frontmatter: yaml\n  }\n}\n\nfunction test (string) {\n  string = string || ''\n\n  return regex.test(string)\n}\n"]},"metadata":{},"sourceType":"script"}